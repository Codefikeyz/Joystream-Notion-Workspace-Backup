# Challenges

# **Purpose**

The purpose of this writeup is to summarise the UX design challenges around our Pioneer product, and specifically what development process should be adopted. As Pioneer is not going to be the only item in the Joystream platform product line which receive substantial UX investment, hopefully some of these conclusions will be transferrable to these other products as well.

# **What is Pioneer?**

![](https://user-images.githubusercontent.com/437292/59360149-e830c380-8d2f-11e9-80f8-e12c2bd9350a.png)

Today, Pioneer refers to a web application that exposes the most important functionality of our current testnet (Acropolis). A hosted version of the application can be found at

[https://testnet.joystream.org/](https://testnet.joystream.org/)

Note: In order to really experience the full functionality of the application, you have to:

1. Create a key by clicking "Create Key" button advertised at the top
2. Claim tokens from the faucet
3. Become a platform member
4. Change the interface from "Basic features only" to "Fully featured" under "Settings

A very helpful additional introduction to the current state of Pioneer can be found in the in the **Background** section of the following issue

[Joystream/joystream#63](https://github.com/Joystream/joystream/pull/63)

As can be gleaned from this issue, we are currently also in the process of making substantial changes to this application at the software engineering level.

# **What is the purpose of Pioneer?**

In the past, and leading up to today, this application has had the following primary goals:

- **Community recruiting:** Pioneer is a hosted web application which allows the user to easily inspect and interact with our current system and community. This low friction, no-install, characteristic is essential. Actually seeing a working product live is a very effective way of conveying to prospective community members what it is we are actually building, how it will work in practice, that other people are currently part of the movement, and that we are likely to actually deliver on our goal. These are all considerations that could motivate someone to start participating in our community.
- **Community training:** Using the application to participate in a live testnet allows community members to understand what is involved in participating in the different platform roles. Different roles have different associated requirements, rewards and risks, and participation is the best way to discover where one fits in, and how the different roles interact. This learning process, both at the individual and community level, provides critical training for the future, when the community will autonomously operate and develop the live platform.
- **Get feedback:** Receiving feedback from users frequently, in order to guide our subsequent investment in protocols, products and policies, is critical for at least two reasons. Firstly, while we broadly know what we want to enable, and what our main constraints are, there are still many ways in which substantive technical and policy details of how the system will work once live is yet unknown. Second, when our products run in production, they are exposed to more ecological technical and social constraints. We cannot substitute for the authenticity level in well designed testnet deployment and policy withy in-house testing or validation process.

## **What is the current state of Pioneer?**

## **Background**

Pioneer is a fork of an application for the Polkadot chain, found in production there

[https://polkadot.js.org/apps/#/explorer](https://polkadot.js.org/apps/#/explorer)

This original application has functionality that is centred around very common features of any Substrate based chain, such as viewing validators, block production, transferring funds, etc. The user interface is based on the visual brand of the Polkadot project, and there is a reusable component library which makes it easy to conveniently augment and extend the application functionality.

## **Development process**

There were three primary determinants of the old process for developing Pioneer.

- We were a small team, with only one front-end developer, and no in-house designer.
- Our system was extremely early stage, with fundamental changes and additions being made frequently.
- The underlying Polkadot/Substrate technology stack and tooling was evolving at a very high pace.
- We were starting from scratch, building a new community around a new vision, and so there was limited scrutiny, attention and expectations around what were building.

As a result, our process involved simply making incremental extensions to this existing application, rather than thinking of the entire experience from scratch as being conceived to support the user objectives in our system. Beyond this, and really because of this original sin, we stuck to a low investment approach in making the extensions themselves, precisely because we did not want to pour precious resources onto a broken foundation. This meant that things like user stories, mockups and user testing were extremely rushed, if not entirely absent.

One aspect of this process worth noting was that since the same person would often be involved building out the blockchain, or other back-end infrastructure, and the user facing experience, there was minimal organisational overhead and coordination required in actually executing.

## **Functionality**

Pioneer evolved as a sequence of incremental extensions upon the base functionality in the original application. The sequence of extensionsś mirrored the features we were introducing in our own testnets over time. We introduced tings like

- users voting in council elections
- council being able to vote on proposals
- a forum
- a membership registry, and a member profile page for each member.
- a media section for viewing and publishing digital media (audio and video)
- a list of current storage providers
- other static sections that had to do with supporting information and relevant links to our hosted instance of Pioneer

We are imminently deploying a new testnet (Rome), where additional functionality will be introduced.

## **What is the problem with Pioneer UX?**

A cursory inspection of how the product looks, feels and functions, reveal a totally broken product. The set of concrete UX problems is too long to list, and in fact not worth listing, as there could be no remedy in attempting to tackle them one-by-one.

# **Why process change, why now?**

While the underlying purpose of Pioneer, as described above, remains the same, the constraints around the development have shifted, and we need to update our process to readjust to a new optimum. Specifically, the constraints have shifted in the following most important ways

- Our team has grown considerably.
- The organisation of our own system has become more stable.
- Tech underlying tech stack from Polkadot/Substrate is much more stable.
- Our system has become significantly more complex, both in terms of different number of user types and functionality, that the lack of deliberate attention to UX is becoming increasingly costly.
- While we still have limited design capacity, we have an actual brand identity for the project that we need to respect.

# **Goals for new process (Pioneer 2.0)**

A new process must address two fundamentally different stages of development, hereinafter referred to as phase 1 and 2, and it may be that a different process is required for each.

## **Phase 1: Catching up**

Firstly, we have to get to a version which simply corresponds to the current state of our network. To complicate matters, this is a moving target, hence this catchup process must advance at a greater pace than this forwards development if we are to hope to conclude this phase.

Any candidate process must resolve at least the following requirements of this phase

### **Knowledge acquisition and transfer**

Future development of Pioneer 2.0 will critically involve new team members with a specialisation in visual product design.

They will very possibly have limited, or at least less than required, background understanding of the conceptual apparatus relevant to Joystream and similar blockchain based systems, including for example

- staking
- slashing
- staked voting
- asymmetric cryptography and public, private key pairs
- signing
- hashing
- transactions and events
- accounts and nonces
- gas or fees
- governance
- full nodes
- indexing nodes
- wallets, key management, key storage and recovery
- more?

**A: What sort of general knowledge acquisition is required**

Even more so, they will most certainly have a very superficial prior understanding of

- the current state of the system overall and Pioneer specifically
- the current set of changes being applied to the system overall and Pioneer specifically
- the current team understanding of constraints and objectives of the system overall and Pioneer

This information is held with the core Jsgenesis team, and is only partially documented across a distributed set of issues, code comments, specifications, social media posts, tutorials, chat logs and so on.

**B: How should this knowledge transfer be organised so as to economise on the time of the existing team and the new team?**

### **Foundational**

Catching up will involve going from zero to one with a totally new UX for Pioneer 2.0, and thus will involve making many foundational decisions that will have substantially constrain future development. Here are some candidate examples

- Should Pioneer 2.0 include any consumer or publisher experience, as it does today, or should this be in separate products?
- Should Pioneer 2.0 be a multilingual product?
- Should Pioneer 2.0 have a consistent means of on-boarding and training new users, or existing user on new features, through wizards, explainers, tips, guides, etc.
- Should there be a fully fledged design system for how to build flows, interactions, screens, dialogs, UI components, event display, etc.
- Should the the new brand identity impact Pioneer 2.0, and if so, how, is it up to the task? does it require augmentation?
- Should Pioneer 2.0 have a consistent means of growing to absorb new features and functionality?
- Should Pioneer 2.0 be distributed through the browser, a desktop application, a mobile application?

**C: What is the full set of such decisions?**

If we keep the set of such decisions narrow, we will add less structure for the future. This has costs and benefits. On the cost side, it means that the quality of the output of the first phase will likely be lower, and building on this foundation in the next phase will likely require continued intensive involvement of design specialists in every aspect, as there is less set structure to allow others to work autonomously. This latter consequence will reduce the speed of iteration by making these members, and their productivity and bandwidth, a bottleneck for the entire team. On the benefit side, it means phase 1 will be easier in every respect (knowledge transfer, production, testing, etc.), and any mistakes made will be easier to correct later.

**D: What process should be used to make a decision in each case?**

### **A moving target**

As mentioned prior, the organisation and function of the system may change in important ways, however, at the current time there are very specific things which we *know* have to change. They may change more than once, presently they are known to change at least once. How do we deal with this?

Here are some examples

- The data storage and distribution system will be totally overhauled, and distributing data will be a new role entirely.
- The permissions system controlling who can do what to the content index will be overhauled.
- The proposal system will be totally overhauled.
- The way staking for voting interacts with all other staking will need to be revisited and likely changed.

One approach would be to refrain from developing Pioneer 2.0 in those respects that depend on the parts of the system that will change, and not launch Pioneer 2.0 until it is reconciled with a stable system. This is not ideal, as its highly uncertain how stable we will believe any part of the system will be over the near term.

**E: How to build for change?**

### **Production & Testing**

The above constraints will ultimately inform a production and testing process, where we go from a defined set of problems, to our solution.

**F: How should this process be structured, and whom should be involved in what way?**

For example:

- In what order is the product built.
- What are the assets produced? e.g. does it include
    - personae development
    - user stories
    - task flows
    - wire flows
    - user flows
    - functional prototypes
    - etc.
- What, if any, validation or testing is conducted.

*Note: This post was helpful to me in getting acquainted some of these concepts*[https://blog.prototypr.io/ux-design-101-thinking-in-user-flows-8b571661866](https://blog.prototypr.io/ux-design-101-thinking-in-user-flows-8b571661866)

## **Phase 2: Moving forward**

The major difference between phase 1 and phase 2 is that in many cases, hopefully more often than not, this process should help us determine what to add or change in the system, rather than the opposite. A more user and community driven process would help us prioritise how to advance Pioneer UX, and ultimately how we choose to advance Pioneer UX has strong implications for how to advance the system in its entirety at every level. These priorities would have to be informed by fundamental technical constraints around soundness, security, technical debt, incentives, maintainability, etc.

Introducing a new UX improvement in Pioneer 2.0 may imply a cascading set of requirements, such as changing the

- front-end code in Pioneer.
- API or behaviour of one or more nodes, such as the query and/or storage node, which may also include some sort of database migration.
- blockchain runtime code, which will also include runtime upgrade and migration code.

**D: How do we organize the work on executing on such improvements across multiple teams, disciplines and levels of abstraction**